# Molecular Dynamics from Scratch in Zig (I)

## The Initial Particle System 

In the most simple, barebones way of explaining it, a molecular dynamics (MD) is a box containing particles which act under the laws of classical, Newtonian mechanics.

#### Particle Structure

```zig
pub const Particle = struct {
    position: [3]f32,
    velocity: [3]f32,
    force: [3]f32,
    mass: f32,
    }
};
```


#### System


#### Initialising a system of $n$ particles randomly distributed within our box

I ran into an embarassing amount of trouble trying to generate a random float value. 

What I ended up doing is generating a random `seed` for a pseudo-random number generator, by getting calling the nanosecond using `std.time`.

```zig
const seed = std.math.lossyCast(u64, std.time.nanoTimestamp());
var rng = std.Random.DefaultPrng.init(seed);
std.debug.print("{}", .{rng.random().float(f32)});
```

Since `std.time.nanoTimestamp()` returns a signed integer of type `i128`, I use the standard library `std.math` package to "cast" it to a `u64`, the data type accepted as an input by `.Random.DefaultPrng.init()` to initiate our random number generator `rng`, from which I can call the `float(f32)` function to generate my desired float value.

Anyway. We want to randomly generate the *positions* for a given particle anywhere within the box, i.e., from 0 to the size of the box in a given dimension. We also want to randomly initialise velocities in all three dimensions, between some maximum velocity `maxVel` and a minimum, `minVel`. 

```zig
pub const System = struct {
    particles: []Particle,
    box_dims: [3]f32,

    pub fn genRandomSystem(self: *System, allocator: *std.mem.Allocator, particle_count: usize, maxVel: f16, minVel: f16) !void {
        self.particles = try allocator.alloc(Particle, particle_count);

        const seed = std.math.lossyCast(u64, std.time.nanoTimestamp());
        var rng = std.Random.DefaultPrng.init(seed);

        for (self.particles) |*particle| {
            for (0..3) |i| {
                particle.position[i] = (rng.random().float(f32) * self.box_dims[i]);
                particle.velocity[i] = (rng.random().float(f32) * (maxVel - minVel) + minVel);
            }
            particle.mass = 1.0;
        }
    }
};
```

And a quick lazy test with 10 particles and velocities randomised between -1 angive us:

```zig
pub fn main() !void {
    var allocator = std.heap.page_allocator;
    const box_dims: [3]f32 = .{ 1, 1, 1 };
    var system = System{
        .box_dims = box_dims,
        .particles = &[_]Particle{},
    };
    try system.genRandomSystem(&allocator, 10, 1, -1);

    for (system.particles) |particle| {
        std.debug.print("{} ", .{particle.velocity[0]});
    }
}
```
```
zig run src/tests.zig 
3.4423137e-1 -9.851909e-1 -9.8291713e-1 5.71592e-1 -4.5127106e-1 3.151822e-2 5.415684e-1 -2.0934075e-1 4.8125732e-1 8.587457e-1
```
It seems like they're all in order.

## What's in a step?
We will be integrating with the velocity verlet method. In practice, this involves several steps:

1. Calculation of the new positions as:

$$
x(t+\Delta t) = x(t) + v(t+\Delta t) + \frac{1}{2}a(t)\Delta t^2
$$

2. Calculation of our new forces

3. Calculation of the new velocities as:

$$
v(t+\Delta t) = v(t) + \frac{a(t)+ a(t+\Delta t)}{2}\Delta t
$$

note: as $a$ is equal to $F/m$ (where $F$ is force and $m$ is mass, we can simply replace $a$ with $F$ in our simple example as we are implicitly considering all particles have an equal mass, 1.

Either way, the forces from before the positions are updated need to be stored in order to calculate the new velocities.


### Calculating Forces

Each particle in the system interacts with all other molecules by way of the inverse square law:

$F = \frac{k}{r^2}$

Where $F$ is the force, $k$ is the interaction (more on this later), and $r$ is the distance between particles.