# Molecular Dynamics from Scratch in Zig (I)

## Creating an initial system
In the most simple, barebones way of explaining it, a molecular dynamics (MD) is a box containing particles which act under the laws of classical, Newtonian mechanics.

### Particles/atoms
A particle is can be represented as a `struct`, containing 3-dimensional values corresponding to it's position, velocity, and force in the x-, y- and z-dimensions. It has a mass, and a couple of extra properties (like charge and Van der Waals radius), which I'll skip over for now.

```zig
pub const Particle = struct {
    position: [3]f32,
    velocity: [3]f32,
    force: [3]f32,
    mass: f32,
    }
};
```


### The system itself
... consists simply of $n$ particles in a box of $x, y, z$.
```zig
pub const System = struct {
    particles: []Particle,
    box_dims: [3]f32,
    }
};
```

#### Initialising a system of $n$ particles randomly distributed within our box

I ran into an embarassing amount of trouble trying to generate a random float value. 

What I ended up doing is generating a random `seed` for a pseudo-random number generator, by getting calling the nanosecond using `std.time`.

```zig
const seed = std.math.lossyCast(u64, std.time.nanoTimestamp());
var rng = std.Random.DefaultPrng.init(seed);
std.debug.print("{}", .{rng.random().float(f32)});
```

Since `std.time.nanoTimestamp()` returns a signed integer of type `i128`, I use the standard library `std.math` package to "cast" it to a `u64`, the data type accepted as an input by `.Random.DefaultPrng.init()` to initiate our random number generator `rng`, from which I can call the `float(f32)` function to generate my desired float value.

Anyway. We want to randomly generate the *positions* for a given particle anywhere within the box, i.e., from 0 to the size of the box in a given dimension. We also want to randomly initialise velocities in all three dimensions, between some maximum velocity `maxVel` and a minimum, `minVel`. The forces are set to 0, as they are calculated at the start of each step.

```zig
pub const System = struct {
    particles: []Particle,
    box_dims: [3]f32,

    pub fn genRandomSystem(self: *System, allocator: *std.mem.Allocator, particle_count: usize, maxVel: f16, minVel: f16) !void {
        self.particles = try allocator.alloc(Particle, particle_count);

        const seed = std.math.lossyCast(u64, std.time.nanoTimestamp());
        var rng = std.Random.DefaultPrng.init(seed);

        for (self.particles) |*particle| {
            for (0..3) |i| {
                particle.position[i] = (rng.random().float(f32) * self.box_dims[i]);
                particle.velocity[i] = (rng.random().float(f32) * (maxVel - minVel) + minVel);
                particle.force[i] = 0;
            }
            particle.mass = 1.0;
        }
    }
};
```

Note the line `try allocator.alloc(Particle, particle_count)`. We're going to need to allocate the memory for all of the particles in our system by using the standard library allocator, which in it's default form is `*std.mem.allocator`. We're the particles to the **heap memory**, which can be accessed whenever we need and persists. I really liked [this video](https://www.youtube.com/watch?v=5OJRqkYbK-4) by Alex Hyett explaining the difference. 

We're going to use Zig's `GeneralPurposeAllocator`, which is called as:
```zig
var gpa = std.heap.GeneralPurposeAllocator(.{}){};
var allocator = gpa.allocator();
```
... a decision I made based on [this explanation](https://zig.guide/standard-library/allocators) on zig.guide

Anyway. Building a box of size [1, 1, 1] with 10 particles, and randomising velocities between -1 and 1 is done as follows:

```zig
pub fn main() !void {

    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    var allocator = gpa.allocator();

    const box_dims: [3]f32 = .{ 1, 1, 1 };

    var system = System{
        .box_dims = box_dims,
        .particles = &[_]Particle{},
    };
    try system.genRandomSystem(&allocator, 10, 1, -1);

    allocator.free(system.particles);
}
```


## What's in a step?

For a given MD step, we first calculate the forces acting on our particles at that given time, and then integrate newton's equation of motion to update the positions and velocities according to the previous positions, velocities and forces.


We will be integrating with the velocity verlet method. In practice, this involves several steps:

1. Calculation of the new positions as:

$$
x(t+\Delta t) = x(t) + v(t+\Delta t) + \frac{1}{2}a(t)\Delta t^2
$$

2. Calculation of our new forces

3. Calculation of the new velocities as:

$$
v(t+\Delta t) = v(t) + \frac{a(t)+ a(t+\Delta t)}{2}\Delta t
$$

note: as $a$ is equal to $F/m$ (where $F$ is force and $m$ is mass, we can simply replace $a$ with $F$ in our simple example as we are implicitly considering all particles have an equal mass, 1.

Either way, the forces from before the positions are updated need to be stored in order to calculate the new velocities.


### Calculating Forces

Each particle in the system interacts with all other molecules by way of the inverse square law:

$F = \frac{k}{r^2}$

Where $F$ is the force, $k$ is the interaction (more on this later), and $r$ is the distance between particles.